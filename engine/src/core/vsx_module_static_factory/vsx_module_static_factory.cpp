
#include <vsx_platform.h>

#include "vsxfst.h"
#include "vsx_math_3d.h"
#include "vsx_command.h"
#include "vsx_param.h"
#include "vsx_module.h"
#include "vsx_timer.h"
#include <list>

#include <vsx_module_static_factory.h>

#include <plugins/static_factory_funcmapping.h>

#undef dlopen
#undef dlsym


// will fill out internal std::maps with pointers to factory functions
vsxm_sf::vsxm_sf()
{
  #define VSXM_SF_ADD_MODULE(name,m_cm,m_dm,m_nm) modules.push_back(new vsxm_sf_info(#name,(void*)m_cm,(void*)m_dm,(void*)m_nm))
  // build the definitions
  #include <plugins/static_factory_funcmapping.cpp>
  // to be auto-generated by cmake
}


// fake dlsym, returns function pointers to static functions
void *vsxm_sf::dlsym(void *handle, const char *symbol)
{
  // handle is assumed to be *vsxm_sf_info cast as void
  /*
    create_new_module
    destroy_module
    get_num_modules
  */
  printf("got dlopen request for: %s\n", symbol);
  vsxm_sf_info* i_handle = (vsxm_sf_info*)handle;
  if (i_handle) {
    if (vsx_string(symbol) == "create_new_module")
      return i_handle->cm;
    if (vsx_string(symbol) == "destroy_module")
      return i_handle->dm;
    if (vsx_string(symbol) == "get_num_modules")
      return i_handle->nm;
  }
  return 0;
}

void vsxm_sf::get_factory_names(std::list<vsx_string>* mfiles)
{
  // crunch up the list
  for (unsigned long i = 0; i < modules.size(); i++)
  {
    (*mfiles).push_back(modules[i]->name);
  }
}

void* vsxm_sf::dlopen(const char *filename)
{
  printf("got dlopen request for: %s\n", filename);
  unsigned long i = 0;
  unsigned long c = modules.size();
  printf("count modules: %d\n", c);
  while (modules[i++]->name != filename && i < c) {
    printf("list name %s\n", modules[i]->name.c_str());
    printf("%d\n", i);
  }
  if (i) --i;
  printf("ifinal: %d\n", i);
  return i != c ? modules[i] : 0;
}

vsxm_sf static_holder;